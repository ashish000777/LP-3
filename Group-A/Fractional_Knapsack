class Item:
    def __init__(self, value, weight):
        self.value = value
        self.weight = weight
        self.ratio = value / weight

def fractional_knapsack(items, capacity):
    """
    Solves the fractional knapsack problem using a greedy method.

    Args:
        items: A list of Item objects.
        capacity: The capacity of the knapsack.

    Returns:
        The maximum value that can be placed in the knapsack.
    """

    # Sort the items in decreasing order of their value-to-weight ratio.
    items.sort(key=lambda item: item.ratio, reverse=True)

    # Initialize the total value and weight in the knapsack.
    total_value = 0
    total_weight = 0

    # Iterate over the items in the sorted order.
    for item in items:
        # If the item fits in the knapsack, add it to the knapsack.
        if item.weight <= capacity - total_weight:
            total_value += item.value
            total_weight += item.weight
        # Otherwise, add a fraction of the item to the knapsack.
        else:
            fraction = (capacity - total_weight) / item.weight
            total_value += fraction * item.value
            total_weight += fraction * item.weight
            break

    return total_value


# Example usage:

# Get user input for the number of items and the capacity of the knapsack.
num_items = int(input("Enter the number of items: "))
capacity = int(input("Enter the capacity of the knapsack: "))

# Create a list of Item objects from the user input.
items = []
for i in range(num_items):
    value = int(input("Enter the value of item {}: ".format(i + 1)))
    weight = int(input("Enter the weight of item {}: ".format(i + 1)))
    items.append(Item(value, weight))

# Solve the fractional knapsack problem and print the maximum value.
max_value = fractional_knapsack(items, capacity)

print("The maximum value that can be placed in the knapsack is {}.".format(max_value))
